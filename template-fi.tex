% --- Template for thesis / report with tktltiki2 class ---

\documentclass[finnish]{tktltiki2}

% tktltiki2 automatically loads babel, so you can simply
% give the language parameter (e.g. finnish, swedish, english, british) as
% a parameter for the class: \documentclass[finnish]{tktltiki2}.
% The information on title and abstract is generated automatically depending on
% the language, see below if you need to change any of these manually.
% 
% Class options:
% - grading                 -- Print labels for grading information on the front page.
% - disablelastpagecounter  -- Disables the automatic generation of page number information
%                              in the abstract. See also \numberofpagesinformation{} command below.
%
% The class also respects the following options of article class:
%   10pt, 11pt, 12pt, final, draft, oneside, twoside,
%   openright, openany, onecolumn, twocolumn, leqno, fleqn
%
% The default font size is 11pt. The paper size used is A4, other sizes are not supported.
%
% rubber: module pdftex

% --- General packages ---

\usepackage[utf8]{inputenc}
\usepackage{moreverb} 
\usepackage{url}
\usepackage{lmodern}
\usepackage{microtype}
\usepackage{amsfonts,amsmath,amssymb,amsthm,booktabs,color,enumitem,graphicx}
\usepackage[pdftex,hidelinks]{hyperref}
\usepackage{setspace}
\doublespacing

% Automatically set the PDF metadata fields
\makeatletter
\AtBeginDocument{\hypersetup{pdftitle = {\@title}, pdfauthor = {\@author}}}
\makeatother

% --- Language-related settings ---
%
% these should be modified according to your language

% babelbib for non-english bibliography using bibtex
\usepackage[fixlanguage]{babelbib}
\selectbiblanguage{finnish}

% add bibliography to the table of contents
\usepackage[nottoc]{tocbibind}
% tocbibind renames the bibliography, use the following to change it back
\settocbibname{Lähteet}

% --- Theorem environment definitions ---

\newtheorem{lau}{Lause}
\newtheorem{lem}[lau]{Lemma}
\newtheorem{kor}[lau]{Korollaari}

\theoremstyle{definition}
\newtheorem{maar}[lau]{Määritelmä}
\newtheorem{ong}{Ongelma}
\newtheorem{alg}[lau]{Algoritmi}
\newtheorem{esim}[lau]{Esimerkki}

\theoremstyle{remark}
\newtheorem*{huom}{Huomautus}


% --- tktltiki2 options ---
%
% The following commands define the information used to generate title and
% abstract pages. The following entries should be always specified:

\title{Tietokantakyselyjen optimointi relaatiotietokannassa}
\author{Olli Rissanen}
\date{\today}
\level{Kandidaatintutkielma}
\abstract{Tutkielmassa tutustutaan tietokantakyselyjen optimointiin relaatiotietokantojen hallintajärjestelmien osalta sekä optimoinnin vaikutukseen kyselyjen suorituskyvyssä. }

% The following can be used to specify keywords and classification of the paper:

\keywords{Information systems → Query optimization}
\classification{} % classification according to ACM Computing Classification System (http://www.acm.org/about/class/)
                  % This is probably mostly relevant for computer scientists

% If the automatic page number counting is not working as desired in your case,
% uncomment the following to manually set the number of pages displayed in the abstract page:
%
% \numberofpagesinformation{16 sivua + 10 sivua liitteissä}
\begin{document}

% --- Front matter ---

\maketitle
\makeabstract
\tableofcontents
\newpage


% --- Main matter ---
\section{Johdanto}
%Konteksti
Modernit järjestelmät lisäävät jatkuvasti tietokantojen työtaakkaa tiedon määrän kasvaessa. Jotta tiedosta saadaan mahdollisimman paljon irti, tarvitaan tiedon hallitsemiseen yhä tehokkaampia työkaluja. % Tiedon hallitsemisesta ja keräämisestä voi muuten koittua rasitteeksi joka ylittää tiedosta saatavat hyödyt. 
Tietokannan suorituskyky on tärkeää koko järjestelmän suorituskyvyn osalta, sillä tiedon lukeminen massamuistista on hidasta verrattuna rekistereiden tai välimuistin käyttöön. Optimoimalla tietokantakyselyjen suoritusta voidaan vaikuttaa suoritettujen operaatioiden määrään sekä muistialueen kokoon ja siten vähentää tietokannan vasteaikaa sekä resurssien käyttöä \cite{mor2012}. 
	
%Tietokannan suorituskyky on ydintekijä olio-relaatiokuvausta (ORM, object-relational mapping) käyttävissä ohjelmointikielissä. ORM luo relaatiotietokannan pohjalta käyttäjälle oliotietokannan, jonka suorituskyky on kuitenkin sidottu relaatiotietokantaan.
% 
%Erityisesti olio-relaatiokuvausta (ORM, object-relational mapping) toteuttavissa ohjelmointikielissä puhtaiden SQL-kyselyjen kirjoittaminen on siirretty käyttäjältä alemmalle tasolle.relaatiotietokantaan. Relaatiotietokannan kyselyjen optimoinnilla pystytään siten saavuttamaan .. [viite ois kiva]

Tietokantaa käytetään tietokannan hallintajärjestelmällä, joka on kokoelma ohjelmia tiedon tallentamiseen, muokkaamiseen, analysoimiseen ja keräämiseen tietokannasta. Hallintajärjestelmää käytetään kyselykielellä, joista esimerkiksi SQL \cite{5391051} on suunniteltu relaatiotietokantojen hallintajärjestelmille. Hallintajärjestelmän vastuulla on kyselyn muuttaminen tietokannan ymmärtämään muotoon säilyttäen kyselyn alkuperäinen tarkoitus. Kyselyn optimointi on toteutettu automaattisena toimenpiteenä hallintojärjestelmän sisältämässä kyselyn optimoijassa, ja kaikista hallintajärjestelmän komponenteista optimoijalla on suurin merkitys tietokannan suorituskykyyn \cite{mor2012}. Kyselyn optimoijan tavoitteena on minimoida itse optimointiin käytetty aika ja maksimoida optimoinnista saatu hyöty \cite{jarke1984}. 

Optimoija toimii arvioimalla mahdolliset menetelmät kyselyn suorittamiseen ja valitsemalla niistä tehokkaimman \cite{selinger1979access}. Menetelmää kyselyn suorittamiseksi sanotaan kyselysuunnitelmaksi, ja se sisältää sarjan tietokannan relaatioihin kohdistuvia algebrallisia operaatioita, jotka tuottavat tulokseksi halutun vastauksen. Tietokantakyselyä vastaavia kyselysuunnitelmia voi olla useita, sillä kysely voidaan usein esittää monena algebrallisesti toisiaan vastaavana esityksenä \cite{jarke1984}. Algebrallista operaatiota kohden voi myös löytyä useita toteutuksia, kuten join-operaatiota toteuttavat merge join, hash join ja nested loop join. Kyselysuunnitelma sisältää operaatioiden lisäksi tiedon ne toteuttavista algoritmeista. Saman kyselyn sisältämät mahdolliset kyselysuunnitelmat voivat olla suorituskyvyltään jopa eri suuruusluokassa \cite{ioannidis1996query, oracle2013refman}. 
%Ongelma

%Pohjan nykyaikaisille kyselyn optimoijille loi System R-hallintajärjestelmän \cite{astrahan1976system} sisältämä optimoija, jonka esittelivät Selinger et al. vuoden 1979 artikkelissaan \cite{selinger1979access}. System R oli ensimmäinen relaatiomalliin \cite{codd1970relational} perustuva hallintajärjestelmä, ja moni nykyinen %hallintajärjestelmä pohjautuu osittain System R:ään.

Tutkielmassa keskitymme kyselyn optimoijan toimintaan ja ongelmiin yleisellä tasolla. Jokainen kaupallinen optimoija on osittain erilainen kokonaisuus komponentteja, jotka kuitenkin pohjautuvat samoihin yleisiin malleihin. Yksittäistä hallintajärjestelmää käsiteltäessä mainitaan siitä erikseen. Tutkielman tavoitteena on tutustuttaa lukija optimoijan toiminnan perusteisiin ja optimoijan ajankohtaisiin ongelmiin.

Optimointi on vaikea hakuongelma, jossa hakualue voi nousta erittäin suureksi. Haasteeksi nousee kyselysuunnitelmien hakeminen ja niiden suorituskyvyn ennustaminen. Kaikkien mahdollisten kyselysuunnitelmien arvioiminen on usein liian hidasta, joten optimoijan tulee valita pienin mahdollinen hakualue joka pitää sisällään halvimmat suunnitelmat \cite{chaudhuri1998}. Suorituskyvyn ennustamisen ja hakualueen rajauksen lisäksi optimoija tarvitsee tehokkaan algoritmin koko hakualueen läpikäymiseen. On epärealistista odottaa kyselyn optimoijan aina löytävän parhaan kyselysuunnitelman, ja onkin tärkeämpää välttää huonoimpia suunnitelmia ja löytää hyvä suunnitelma \cite{ramakrishnan2003database}. 

Luku 2 sisältää esitiedot kyselyn optimoijan toiminnalle, jonka lisäksi kappaleessa perehdytään optimoijan historiaan. Luku 3 tiivistää tietokantakyselyn prosessoinnin hallintajärjestelmän sisällä ja esittelee optimoijan toiminnan pääpiirteittäin kyselyn prosessoinnissa. Optimoijan toimintaan tarkemmin syvennytään luvussa 4, jossa käsitellään kyselysuunnitelman luomista, kustannusarviointia ja parhaan kyselysuunnitelman valintaa. Kyselyn sisältämien alikyselyjen prosessointi käydään läpi luvussa 5.

\section{Taustaluku}
\subsection{Relaatiomalli}

Relaatiotietokanta on relaatiomalliin \cite{codd1970relational} perustuva tietokanta. Relaatiomallin keskeinen piirre on kaiken datan esittäminen n-paikkaisen karteesisen tulon osajoukkona, ja se tarjoaa deklaratiivisen menetelmän datan ja kyselyjen määrittämiseen. Relaatiomalli koostuu attribuuteista, monikoista ja relaatioista. Matemaattisessa määritelmässä attribuutti on pari joka sisältää attribuutin nimen ja tyypin sekä jokaiseen attribuuttiin liittyy sen arvojoukko. Monikko on järjestetty joukko attribuuttien arvoja. Relaatio koostuu otsakkeesta ja sisällöstä, jossa otsake on joukko attribuutteja ja keho on joukko monikkoja. Relaation otsake on myös jokaisen monikon otsake. Visuaalisessa esityksissä relaatio on taulukko ja monikko taulukon rivi. 

\begin{figure}[!h]
  \caption{Relaatiomalliin perustuva tietokanta}
  \centering
    \includegraphics[width=\textwidth]{rlt_wiki.png}
\end{figure}

\subsection{Optimoijan tavoitteet}
Tietokantakyselyjen optimoinnilla viitataan tietokantakyselyn suorittamiseen mahdollisimman tehokkaasti. Optimoinnin tavoitteena on joko maksimoida suorituskyky annetuilla resursseilla tai minimodia resurssien käyttö. Jarke ja Koch määrittelivät artikkelissaan \cite{jarke1984} mitattaviksi resursseiksi suorittimen ja muistin käytön sekä kommunikointikustannukset. Teorey ja Fry \cite{teorey1982design} huomasivat optimoijan vaikuttavan suorittimen palveluaikaan (service time), suorittimen jonotusaikaan, I/O:n palveluaikaan, I/O:n jonotusaikaan ja lukittumisen viiveeseen. Osa tutkimuksista, kuten Kooi:n väitöskirja \cite{kooi1980optimization} kuitenkin sivuuttavat suorittimen käytön kokonaan.

Muistin käyttö jakautuu tallennuskustannukseen sekä ulkomuistiin pääsyn kustannukseen. Tallennuskustannuksella tarkoitetaan ulkomuistin sekä puskurimuistin käyttöä, ja se tulee aiheelliseksi kun muistin käyttö aiheutuu pullonkaulaksi. Kommunikointikustannukset käsittävät tiedon viennin tallennuspaikasta laskentapaikkaan ja edelleen tulosten esityspaikkaan. Ne jakautuvat kommunikaatioväylän käyttökustannukseen ja tiedonsiirrosta aiheutuvaan suorittamisen viiveeseen.

Resurssin merkitys riippuu tietokantatyypistä. Jarke ja Koch erittelivät hajautetuissa tietokannoissa kommunikointikustannukset hallitseviksi kustannuksiksi, kun taas paikallisesti hajautetuissa tietokannoissa kaikilla resursseilla on sama painoarvo. Jarken ja Kochin mukaan keskitetyissä tietokannoissa ulkomuistiin pääsyn kustannus ja prosessorin käyttö ovat oleellisia. Tässä tutkielmassa keskitymme erityisesti keskitettyjen tietokantojen optimointiin.

\subsection{Optimoijan historia}
Kun Coddin relaatiomallin pohjalle luotiin sitä toteuttavia kieliä, nousi vuonna 1974 kehitetty SQL nopeasti käytetyimmäksi. SQL:n myötä optimoinnista tuli osa järjestelmän toiminnallisuutta, sillä SQL tarjosi deklaratiivisuutensa vuoksi useita tapoja toteuttaa kukin kysely. Ennen relaatiomallin käyttöä optimointi tehtiin käsin.
Selinger et al. esittelivät artikkelissaan \cite{selinger1979access} System R-tietokantaohjelmiston OPTIMIZER-komponentin, joka on ensimmäisiä relaatiomalliin pohjautuvia kyselyn optimoijia. OPTIMIZER esittely dynaamisen hakualgoritmin kyselysuunnitelmien luomiseen, ja se on käytössä hieman muunneltuna käytännössä kaikissa kaupallisissa järjestelmissä \cite{ioannidis1996query}. 

%\section{Kyselyn jäsentäminen} 
%http://docs.oracle.com/cd/B28359_01/server.111/b28318/sqlplsql.htm#i1243

\section{Tietokantakyselyn prosessointi}
Tietokannan hallintajärjestelmän suorittama SQL-kyselyn prosessointi sisältää useita vaiheita. Kuva 2 esittää kyselyn optimointikerroksen ja suorituskerroksen hallintajärjestelmän sisällä. Alempana analysoimme komponenttien toimintaa tarkemmin.

\begin{figure}[!h]
  \caption{Kyselyn jäsentäminen, optimointi ja suoritus \cite{ramakrishnan2003database}}
  \centering
    \includegraphics[width=\textwidth]{optimoija60.png}
\end{figure}

\subsection{Kyselyn jäsentäminen}
Kyselyn prosessointi alkaa kyselyn jäsentäjän suorittamalla kyselyn syntaksin validoinnilla. \cite{selinger1979access} Osa hallintajärjestelmistä, kuten Oracle 11g, validoi myös samalla semantiikan oikeellisuuden \cite{oracle2009doc}. 
Syntaksin validoinnissa jäsentäjä tarkastaa kyselyn lauseopin oikeellisuuden. Semantiikan validoinnissa tarkastetaan objektien aitous, kyselyn yksiselitteisyys, oikeus haettavaan tietoon ja muuttujien tyypin sopivuus sarakkeiden tyyppeihin. Useat hallintajärjestelmät myös
tallentavat kyselyt validoinnin jälkeen talteen, jotta samaa kyselyä ei tarvitse jäsentää ja optimoida uudelleen. Yksi esimerkki kyselyjä tallentavasta hallintajärjestelmästä on Oracle Database, jossa tallennuspaikkaa kutsutaan nimellä Shared Pool \cite{oracle2005doc}. 

Seuraavaksi jäsentäjä jakaa kyselyn lohkoihin (block) siten, että yhdessä lohkossa on täsmälleen yksi SELECT-lause, yksi FROM-lause ja korkeintaan yksi WHERE-, GROUP BY- ja HAVING-lause \cite{ramakrishnan2003database}. 
Kyselyn mahdollisesti sisältämät alikyselyt muodostavat kukin oman lohkonsa. Alikyselyitä tarkastellaan kappaleessa 5.

Jokainen lohko jäsennetään puuksi, joka on kyselyn algebrallinen esitysmuoto \cite{mahajan2012}. 
Puun solmu sisältää yhden operaation kyselyn suorittamiseksi, ja sillä on nolla tai useampi alisolmua joiden ulostuloa (output) käytetään sen syötteenä.
Esimerkiksi join-operaatiossa solmulla on kaksi alisolmua, joille toteutetaan join-operaatio ja sort-operaatiolla on yksi alisolmu joka järjestetään.
Lehtisolmut ovat solmuja jotka suorittavat hakuja (scan) levyltä ja palauttavat saadut tulokset. 
Puu suoritetaan lehtisolmuista juureen.

Tämän jälkeen monimutkaiset kyselyt uudelleenkirjoitetaan (rewrite) soveltamalla niihin muutossääntöjä \cite{ioannidis1996query}. Pirahesh et al tutkivat uudelleenkirjotusta Starburst-hallintajärjestelmän osalta artikkelissa \cite{pirahesh1992extensible}, ja määrittivät uudelleenkirjoituksen tavoitteiksi tehdä kyselyistä mahdollisimman deklaratiivisia ja suorittaa luonnollisia heuristiikkoja, kuten predikaattien siirtämistä mahdollisimman aikaiseen vaiheeseen.
%Viitteiden käytöstä: aiemmassa artikkelissa määritellään uudelleenkirjoituksen paikka, toisessa sen toiminta.

% valitsemalla hakumetodit (access method), liittämisjärjestyksen (join orders) ja liittämistavat (join methods) tietokannan käyttämien heuristiikkojen pohjalta.  Monimutkaisille kyselyille sovelletaan myös muunnossääntöjä \cite{mahajan2012}.
%Uudelleenkirjoituksen tarkoitus on helpottaa optimoijan työtä parhaan kyselysuunnitelman valinnassa.
%todo: http://docs.oracle.com/cd/A97630_01/server.920/a96520/qr.htm
%http://www.budaconsulting.com/blog/bid/79324/Query-Rewrite-What-is-MySQL-Doing-To-My-Queries

\subsection{Kyselyn optimointi}
Kun kysely on jäsennetty ja mahdollisesti uudelleenkirjoitettu, lähetetään se kyselyn optimoijalle. Kyselyn optimoija hakee tietokannan systeemitaulustoon tallennettua tilastotietoa kyselyyn liittyvistä relaatioista ja relaatioihin liittyvistä saantipoluista. Tilastotietoa käytetään kyselyn suorituskyvyn arviointiin. Saantipolku on menetelmä jolla taulurivit haetaan taulusta, ja se koostuu joko tiedoston lukemisesta tai indeksistä ja siihen liittyvistä valinnoista. Selinger et. al. tutkivat kattavasti saantipolkujen kustannusarviointia artikkelissaan \cite{selinger1979access}. 

Mikäli kyselyn semantiikkaa ei ole vielä tarkastettu, tarkastaa optimoija kyselyn semantiikan oikeellisuuden ja kyselyn tyyppien sopivuuden sarakkeisiin ja operaatioihin systeemitaulun tiedon pohjalta. (Selvennä tästä kappaleen loppuun) Optimoija määrittää lohkojen suoritusjärjestyksen ja prosessoi jokaisen lohkon FROM-lauseeseen liittyvät relaatiot. Mikäli lohkossa on useampi relaatio, arvioi optimoija join-operaation permutaatioiden suorituskyvyt ja valitsee tehokkaimman algoritmin operaation suorittamiseen. Optimoija valitsee jokaiselle lohkolle tehokkaimman saantipolun ja rakentaa niistä kyselysuunnitelman. \cite{selinger1979access} (koko kappaleen viite, korjaa)

\subsection{Kyselyn suorittaminen}
Seuraavassa vaiheessa kysely suoritetaan käyttämällä optimoijan tuottamaa kyselysuunnitelmaa. Suorittamisessa kyselysuunnitelma muutetaan suoritettavaksi konekieleksi ja kyselyn lähteen mukaan joko suoritetaan tai tallennetaan muistiin myöhempää suorittamista varten. 

\section{Optimoijan toiminta} %Komponenteittain? Kyselysuunnitelman kustannusarvioijan tulee . . .
Kyselyn optimoijan tulee hakea mahdolliset kyselysuunnitelmat ja arvioida niiden kustannus. Kappale on jaettu kolmeen osa-alueeseen, joista aluksi perehdymme kyselysuunnitelman rakenteeseen. Tämän jälkeen tutkimme kyselysuunnitelmien tuottamista ja siihen käytettäviä yleisiä algoritmeja. Lopuksi perehdymme kyselysuunnitelmien kustannusarviointiin.

\subsection{Kyselysuunnitelma}
Kyselysuunnitelma koostuu laajennetusta relaatioalgebrapuusta, jossa jokainen solmu kuvaa algebrallista operaatiota. Solmuun on liitetty tieto käytettävästä hakumetodista tiedon hakemiseen taulusta ja suoritusmetodista relaatio-operaation suoritukseen. Tutkitaan seuraavaa SQL-kyselyä:

\begin{frame}

SELECT K.nimi

FROM Kirjat K, Teokset T

WHERE K.tid = T.tid AND K.kid = 5 AND T.arvosana $\textgreater$  3
\end{frame}
\\\newline
Kysely voidaan tulkita relaatioalgebrassa seuraavasti:

\begin{frame}

$\pi$$_{nimi}$(\sigma_{kid=5 \wedge arvosana \textgreater 3}(Kirjat$\Join$$ _{tid=tid}$Teokset))
\end{frame}
\\\newline
Kysely voidaan suorittaa esimerkiksi käyttäen join-operaatiossa nested loop join-algoritmia, jonka jälkeen jokaiselle riville suoritetaan 
valinta ja projektio. Kyselyä vastaava esimerkkikyselysuunnitelma esitetään kuvassa 3.

\begin{figure}[!h] 
  \caption{Kyselysuunnitelma erimerkkikyselylle}
  \centering
    \includegraphics[width=\textwidth]{queryevalplan60.png}
\end{figure}
\\\newline
Join-operaatiossa voidaan käyttää hyväksi putkitusta (pipelining) \cite{dalvi2001pipelining}, jossa operandi putkitetaan suorituksen aikana toiseen operaatioon ilman väliaikaista taulua tuloksen tallentamiseen, lennossa. Ilman putkitusta väliaikaiset tulokset tulee materialisoida. Putkitusta käytetään usein peräkkäisten join-operaatioiden toteuttamiseen, jolloin jokainen operaation palauttama operandi voidaan syöttää seuraavan operaation parametriksi. Putkitusta voidaan käyttää operaation suorittavan algoritmin salliessa sen.

Usein tehokkaampi tapa kyselyn suorittamiseen on suorittaa valinnat mahdollisimman aikaisessa vaiheessa. \cite{ramakrishnan2003database} Esimerkkikyselyssä tauluille suoritetaan kullekin valinta erikseen, joten suorittamalla ne ennen join-operaatiota voidaan vähentää yhdistettävien alkioiden määrää. Tehokkaampi kyselysuunnitelma aikaisilla valinnoilla, tallentaen valinnat väliaikaismuuttujiin T1 ja T2, esitetään kuvassa 4.

 \begin{figure}[!h] %Tottakai parempi tapa tähän olisi hakea vain kid = 5 ja arvosana > 3 matchaavat alkiot ENNEN joinia
  \caption{Toinen kyselysuunnitelma erimerkkikyselylle}
  \centering
    \includegraphics[width=\textwidth]{queryevalplan60better.png}
\end{figure}
\\\newline
%
%Optimoijan tulee arvioida tulosjoukon koko valintojen jälkeen. Kappaleessa 4.3 tutkitaan tarkemmin tulosjoukon koon arviointia.

Valinnan suorittaminen mahdollisimman aikaisin ei kuitenkaan aina tuota suorituskykyisintä tulosta. \cite{ramakrishnan2003database} Mikäli taulut on indeksoitu, voi valinta kadottaa tärkeät indeksit jolloin join-operaation suorittaminen hidastuu. Paras kyselysuunnitelma riippuu siten täysin taulujen koosta ja niiden indeksoinnista. Edelleen tehokkaampi tapa olisi väliaikaisen muuttujan käytön sijaan putkittaa valinta-operaatiosta alkiot suoraan join-operaatioon.

\subsection{Kyselysuunnitelmien tuottaminen}
%Kyselyn optimoijan tulee rakentaa mahdollisten kyselysunnitelmien joukko. 
Kyselyn optimoija tarvitsee tehokkaan algoritmin mahdollisten kyselysuunnitelmien luomiseen. Jarke ja Koch määrittelivät artikkelissaan \cite{jarke1984} kaksi tapaa kyselysuunnitelman valintaan. Ensimmäisessä tavassa arvioidaan jokaisen erillisen kyselysuunnitelman kustannus, jolloin hyvä suunnitelma löydetään mutta optimointiin kulunut aika on suuri. Toisessa tavassa kustannus lasketaan inkrementaalisesti niiden rakentamisen aikana, ja suorituskyvyltään huonoksi havaitut kyselysuunnitelmat karsitaan pois. Selinger et al. esittelemä dynaaminen algoritmi \cite{selinger1979access} on toisen tavan laajennus, jossa algoritmi arvioi operaation ja sen mahdolliset vaikutukset seuraaviin operaatioihin kerrallaan. 

Kyselysuunnitelmat sisältävä hakualue voi kasvaa erittäin suureksi kyselyn ollessa laaja. Useat optimoijat käyttävät heuristiikkoja, kuten valinnan suorittamista mahdollisimman aikaisin tai vain tietynlaista join-operaatioiden järjestyksen hyväksymistä, pienentääkseen kyselysuunnitelmien määrää. Optimoija voi näin karsia tarkasteltavien kyselysuunitelmien määrää. Tavoitteena on pitää hakualue mahdollisimman pienenä, sisältäen kuitenkin optimaalisen suunnitelman \cite{jarke1984}. Luvussa tutustutaan tarkemmin dynaamisiin algoritmeihin sekä vaihtoehtoisiin algoritmeihin hakualueen läpikäymiseen, kuten sääntöihin perustuvaan Starburst-hallintajärjestelmälle kehitettyyn algoritmiin \cite{lohman1988grammar}. Luvun lopuksi käsitellään yleisiä optimoijan käyttämiä heuristiikkoja.

%Chaudhurilla paljon tietoa http://www.cs.washington.edu/education/courses/cse544/99sp/chaudhuri.pdf
\subsubsection{Dynaamiset algoritmit}
Selinger et al. System R:lle esittelemä algoritmi on dynaaminen karsiva ja tyhjentävä (exhaustive) hakualgoritmi. Dynaamista algoritmia pidetään standardina algoritmina optimoijalle, ja usean hallintajärjestelmän hakualgoritmi pohjautuu dynaamiseen algoritmiin sisältäen kuitenkin hieman variaatioita. Algoritmi rakentaa kaikki mahdolliset join-puut ja karsii alioptimaalisiksi tiedetyt puut.
\subsubsection{Muut algoritmit}
Dynaamisia algoritmeja on kritisoitu tästä ja tästä \cite{tähän}...
\subsubsection{Algoritmien heuristiikat}
Optimoija voi suorittaa usean peräkkäisen join-operaation liittämisen monella eri tavalla. Ono ja Lohman tutkivat join-operaation suorittamisjärjestysten vaikutusta tarkemmin artikkelissaan \cite{ono1990}, ja huomasivat join-operaation järjestyksen olevan hallitseva kustannus kyselyn optimoinnissa. 

Tutkitaan kyselyä $Kirjat \Join Teokset \Join Kirjailijat \Join Maat$. Vasemmalta syväksi (left-deep) puuksi kutsutaan tapaa liittää kyselyt seuraavasti: $(((Kirjat \Join Teokset) \Join Kirjailijat) \Join Maat)$, jossa oikea lapsi on aina kantataulu. Kuva 5 havainnollistaa vasemmalta syvät ja lehtevät puut. Optimoijat käyttävät usein pelkästään vasemmalta syviä puita, sillä eri tapoja liittää join-operaatioita on join-operaatioiden määrän kasvaessa erittäin paljon. Käyttämällä vain vasemmalta syviä puita voidaan pienentää hakualuetta merkittävästi. \cite{left-deeppejä tutkiva artikkeli} Toinen syy on vasemmalta syvien puiden mahdollistama putkitus. Oikea lapsisolmu eli join-operaation sisempi taulu täytyy aina materialisoida, sillä se täytyy käydä läpi jokaiselle ulomman taulun eli vasemman lapsisolmun monikolle \cite{ramakrishnan2003database}. 

\begin{figure}[!h]
  \caption{Vasemmalta syvät ja lehtevät puut}
  \centering
    \includegraphics[width=\textwidth]{leftdeepbushytrees.png}
\end{figure}

Ionaddis tutki artikkelissaan \cite{ioannidis1991left} left-deep puiden ja lehtevien (bushy) puiden suorituskykyeroja, ja huomasi lehtevien puiden optimoinnin olevan helpompaa ja sen tuottavan parempia tuloksia. 

\subsection{Kyselysuunnitelmien kustannusarviointi}
%(todo: siisti tämä alku)

Kyselysuunnitelmien kustannusarvioinnissa optimoijan tulee arvioida kyselysuunnitelman operaatioiden suorittamiseen kuluva aika sekä niiden tulosjoukon koko. Kyselysuunnitelman kustannus on sen sisältämien operaatioiden kustannusten summa, ja operaatioiden kustannukseen vaikuttaa olennaisesti sen operandien koko. Yksittäisten operaatioiden kustannus arvioidaan käyttämällä systeemitaulustoon tallennettua tilastotietoa operandeihin liittyvistä tiedoista, kuten järjestyksestä ja koosta. Kappaleessa 4.3.1 tutustutaan tarkemmin systeemitaulustoon, ja kappaleessa 4.3.2 käsitellään systeemitauluston tilastotiedon pohjalta tehtävää kyselysuunnitelman kustannusarviointia.

%Kustannusarviointi koostuu kahdesta vaiheesta: ensiksi arvioidaan jäsennetyn puun jokaisen alkion operaation suorittamiseen kuluva aika.
%Tämän jälkeen arvioidaan jokaisen alkion tulosjoukon koko, sekä tarkastetaan onko tulosjoukko järjestetty. Solmun tulosjoukko on ylisolmun syöte, joten sen koko ja järjestys vaikuttavat suoraan ylisolmun arviointiin.
%(1) Taulujen luku
%(2) Väliaikaisten taulujen luoti
%(3) sort

\subsubsection{Systeemitaulustoon tallennettu tilastotieto}
Systeemitaulusto sisältää tietokannan tilastollisen profiilin. Tilastotiedon avulla pyritään arvioimaan predikaattien ja operaatioiden kustannuksia käyttämällä tilastotietoa niiden operandeista. Mannino et al. tutkivat kattavasti tilastotiedon käyttöä kyselyn optimoinnissa artikkelissaan \cite{mannino1988statistical}. Heidän mukaan tarkka tilastotiedon tallentaminen on tärkeää kyselyn optimoinnille, mutta liian täsmällinen tallentaminen aiheutuu rasitteeksi.

Artikkelissa tilastollinen profiili jaettiin neljään kategoriaan: (1) keskitietoihin kuten moodi, mediaani ja keskiarvo,  (2) hajontaan kuten varianssi sekä pienin ja suurin arvo, (3) kokoon kuten mahtavuus ja eri arvojen lukumäärä sekä (4) frekvenssin jakaantumiseen kuten normaalius ja tasaisuus. Systeemitaulusto sisältää myös jokaisesta taulusta tiedot sen nimestä ja tiedoston nimestä,  attribuuttien tyypeistä ja nimistä, indekseistä ja niiden nimistä ja hakuavaimista sekä yleisistä tiedoista kuten sivukoosta ja puskurimuistin koosta.

Bruno et al. tarkastelivat tutkimuksessaan \cite{bruno2002exploiting} tilastotiedon laajentamista väliaikaisiin tuloksiin, ja he huomasivat ratkaisun tuottavan parempia kyselysuunnitelmia kuin pelkän tietokannan taulun tilastotiedon käytön.

\subsubsection{Tulosjoukon koon arviointi}
Operaation kustannus riippuu syötteen koosta. Tutkitaan seuraavaa tapausta:
\newline

\begin{frame}

SELECT attribuuttit

FROM relaatiot

WHERE ehto 1 $\wedge$ ehto 2 $\wedge$ ... $\wedge$ ehto n
\end{frame}
\\\newline
Kyselyn palauttamien monikkojen maksimimäärä on relaatioiden karteesinen tulo. Jokainen WHERE-ehto harventaa monikkojen määrää. WHERE-ehdon vaikutusta tulosjoukon kokoon voidaan mallintaa lisäämällä jokaiseen ehtoon vähennyskerroin, joka on oletettu suhde lähtöjoukosta tulosjoukkoon vain kyseisen ehdon osalta. 
Tulosjoukon koko voidaan siten arvioida kertomalla maksimijoukko vähennyskertoimien tulolla. \cite{ramakrishnan2003database}

WHERE-lauseen ehtojen kertoimia voidaan laskea hyödyntämällä systeemitaulustoon tallennettua tilastotietoa. Mikäli relaatiolle ei ole tilastotietoa saatavilla, oletetaan relaation olevan pieni ja käytetään määriteltyä vakiota lasketun kertoimen sijaan. \cite{selinger1979access} Oletetaan seuraavat tiedot: %source: https://www.cs.duke.edu/courses/compsci516/cps216/spring03/papers/selinger-etal-1979.pdf
\\\newline
NKeys(I) = eri avainten lukumäärä indeksissä I
\\
F = vähennyskerroin
\\\newline
$sarake = arvo$ 
\\
tyyppiselle ehdolle vähennyskerroin voidaan arvioida kaavalla $F = \frac{1}{NKeys(I)}$, jos sarakkeessa on indeksi kyseiselle relaatiolle. \cite{selinger1979access} Ilman indeksiä kyselyn optimoija käyttää kiinteää arvoa vähennyskertoimen arvioimiseen, joka esimerkiksi System R-relaatiotietokantaohjelmassa on 1/10.
\\\newline
$sarake1 = sarake2$ 
\\
tapauksessa voidaan vähennyskerroin arvioida kaavalla $F = \frac{1}{MAX (NKeys(I1), NKeys(I2))}$ jos kummassakin sarakkeessa on indeksi. Lisäksi oletetaan, että jokaisesta pienemmän indeksin arvoa vastaa arvo toisesta indeksistä. Mikäli vain toisessa sarakkeessa on indeksi, 
voidaan kustannus laskea aiemmalla kaavalla käyttäen indeksin omaavaa saraketta. Mikäli kummassakaan sarakkeessa ei ole indeksiä, arvioidaan arvoksi 1/10.
\\\newline
$sarake > arvo$
\\
tapauksessa voidaan käyttää kaavaa $F = \frac{\textit{suurin avain - arvo}}{\textit{suurin avain - pienin avain}}$. Mikäli sarake ei ole aritmeettinen tai arvoa ei tiedetä käytetään vakiona arvoa 1/3.
\\\newline
\textit{sarake IN (lista arvoja)}
\\
$F = koko(lista) \times (sarake = arvo)$

%Kustannusten arviointi vaatii tilastotietoa. \cite{ramakrishnan2003database}

%Eka osa tähän
%todo: täsmennä ja siisti
%(sis. systeemitaulustoon tallennetun tilastotiedon käytön)
%Tilastotieto on..
%Tilastotiedoilla lasketaan kyselysuunnitelmien kustannusarvio ja valitaan pienimmän kustannusarvion omaava suunnitelma.
%Tietoa ei tallenneta jatkuvasti, sillä se aiheuttaisi esimerkiksi rinnakkaisuusongelmia. Tietokannan valvoja 
%triggeriöi päivityksen esim. komennolla optimize db. Tilastotiedon harvan päivityksen takia valituksi ei aina välttämättä tule 
%tehokkain suunnitelma.

%mielenkiintoisia aiheita:
%NESTED SUBQUERIES
%\section{Fyysinen optimointi (physical optimization)}
\section{Alikyselyt}

Kyselyn predikaatin operandin ollessa toinen kysely puhutaan alikyselystä. Alikyselyt suoritetaan..

Alikysely voi palauttaa yhden arvon tai listan arvoja riippuen sen operandista. Tutkitaan seuraavaa kyselyä:

\newline

\begin{frame}

SELECT nimi

FROM Kirjat

WHERE hinta = 

(SELECT AVG(hinta)
		
FROM Kirjat)
\end{frame}
\\\newline
Esimerkkikyselyssä alikysely palauttaa yhden arvon, AVG(hinta). Tämä arvo lisätään ylikyselyyn predikaatiksi niinkuin se olisi ollut osa ylempää kyselyä. Esimerkkitapauksessa keskiarvon ollessa 10 predikaatti on "hinta = 10".

Mikäli alikysely palauttaa useamman arvon, kuten seuraavassa tapauksessa:

\newline

\begin{frame}

SELECT nimi

FROM Kirjat

WHERE hinta IN (SELECT hinta
		
	FROM Kirjat

	WHERE genre = 'scifi')
\end{frame}
\\\newline
käytetään alikyselyn palauttamaa listaa ylikyselyn predikaattina. Esimerkkikyselyn palauttaessa listan (5,15) vastaava ylikyselin predikaatti on "hinta IN (5,15).

\section{Yhteenveto}

\newpage



%\bibliographystyle{unsrt}
\bibliographystyle{babalpha}
\bibliography{references-fi}


\end{document}
