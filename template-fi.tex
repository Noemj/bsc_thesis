% --- Template for thesis / report with tktltiki2 class ---

\documentclass[finnish]{tktltiki2}

% tktltiki2 automatically loads babel, so you can simply
% give the language parameter (e.g. finnish, swedish, english, british) as
% a parameter for the class: \documentclass[finnish]{tktltiki2}.
% The information on title and abstract is generated automatically depending on
% the language, see below if you need to change any of these manually.
% 
% Class options:
% - grading                 -- Print labels for grading information on the front page.
% - disablelastpagecounter  -- Disables the automatic generation of page number information
%                              in the abstract. See also \numberofpagesinformation{} command below.
%
% The class also respects the following options of article class:
%   10pt, 11pt, 12pt, final, draft, oneside, twoside,
%   openright, openany, onecolumn, twocolumn, leqno, fleqn
%
% The default font size is 11pt. The paper size used is A4, other sizes are not supported.
%
% rubber: module pdftex

% --- General packages ---

\usepackage[utf8]{inputenc}
\usepackage{moreverb} 
\usepackage{url}
\usepackage{lmodern}
\usepackage{microtype}
\usepackage{amsfonts,amsmath,amssymb,amsthm,booktabs,color,enumitem,graphicx}
\usepackage[pdftex,hidelinks]{hyperref}
\usepackage{setspace}
\usepackage[ansinew]{inputenc}   % Windows
\usepackage[T1]{fontenc}
\usepackage[finnish]{babel}
\linespread{1.3}

% Automatically set the PDF metadata fields
\makeatletter
\AtBeginDocument{\hypersetup{pdftitle = {\@title}, pdfauthor = {\@author}}}
\makeatother

% --- Language-related settings ---
%
% these should be modified according to your language

% babelbib for non-english bibliography using bibtex
\usepackage[fixlanguage]{babelbib}
\selectbiblanguage{finnish}

% add bibliography to the table of contents
\usepackage[nottoc]{tocbibind}
% tocbibind renames the bibliography, use the following to change it back
\settocbibname{Lähteet}

% --- Theorem environment definitions ---

\newtheorem{lau}{Lause}
\newtheorem{lem}[lau]{Lemma}
\newtheorem{kor}[lau]{Korollaari}

\theoremstyle{definition}
\newtheorem{maar}[lau]{Määritelmä}
\newtheorem{ong}{Ongelma}
\newtheorem{alg}[lau]{Algoritmi}
\newtheorem{esim}[lau]{Esimerkki}

\theoremstyle{remark}
\newtheorem*{huom}{Huomautus}


% --- tktltiki2 options ---
%
% The following commands define the information used to generate title and
% abstract pages. The following entries should be always specified:

\title{Tietokantakyselyjen optimointi relaatiotietokannassa}
\author{Olli Rissanen}
\date{\today}
\level{Kandidaatintutkielma}
\abstract{Tietokantakyselyn optimointi on kriittistä relaatiotietokannan suorituskyvyn kannalta. Tutkielmassa tutustutaan tietokantakyselyjen optimointiin relaatiotietokantojen hallintajärjestelmien osalta sekä optimoinnin vaikutukseen kyselyjen suorituskyvyssä. Kyselyn optimointia tarkastellaan vaikeana hakuongelmana, ja tutkitaan olemassa olevia ratkaisuja ongelman ratkaisemiseen. \\\newline ACM Computing Classification System (CCS): \newline \textbf{Information systems $\rightarrow$ Query optimization} \newline Theory of computation $\rightarrow$ Database query processing and optimization (theory)}

% The following can be used to specify keywords and classification of the paper:

\keywords{Tietokantakysely, optimointi, relaatiotietokanta}
%\classification{Information systems → Query optimization Information systems → Database query processing} % classification according to ACM Computing Classification System (http://www.acm.org/about/class/)
                  % This is probably mostly relevant for computer scientists

% If the automatic page number counting is not working as desired in your case,
% uncomment the following to manually set the number of pages displayed in the abstract page:
%
% \numberofpagesinformation{16 sivua + 10 sivua liitteissä}
\begin{document}

% --- Front matter ---

\maketitle
\makeabstract
\tableofcontents
\newpage

\setlength{\parskip}{\medskipamount}
\setlength{\parindent}{0pt}



% --- Main matter ---
\section{Johdanto}
%Konteksti
Modernit järjestelmät lisäävät jatkuvasti tietokantojen työtaakkaa tiedon määrän kasvaessa. Jotta tiedosta saadaan mahdollisimman paljon irti, tarvitaan tiedon hallitsemiseen yhä tehokkaampia työkaluja. % Tiedon hallitsemisesta ja keräämisestä voi muuten koittua rasitteeksi joka ylittää tiedosta saatavat hyödyt. 
Tietokannan suorituskyky on tärkeää koko järjestelmän suorituskyvyn osalta, sillä tiedon lukeminen massamuistista on hidasta verrattuna rekistereiden tai välimuistin käyttöön. Optimoimalla tietokantakyselyjen suoritusta voidaan vaikuttaa suoritettujen operaatioiden määrään sekä muistialueen kokoon ja siten vähentää tietokannan vasteaikaa sekä resurssien käyttöä \cite{mor2012}.  Tutkielman tavoitteena on tutustuttaa lukija optimoijan toiminnan perusteisiin ja optimoijan ajankohtaisiin ongelmiin. 
	
%Tietokannan suorituskyky on ydintekijä olio-relaatiokuvausta (ORM, object-relational mapping) käyttävissä ohjelmointikielissä. ORM luo relaatiotietokannan pohjalta käyttäjälle oliotietokannan, jonka suorituskyky on kuitenkin sidottu relaatiotietokantaan.
% 
%Erityisesti olio-relaatiokuvausta (ORM, object-relational mapping) toteuttavissa ohjelmointikielissä puhtaiden SQL-kyselyjen kirjoittaminen on siirretty käyttäjältä alemmalle tasolle.relaatiotietokantaan. Relaatiotietokannan kyselyjen optimoinnilla pystytään siten saavuttamaan .. [viite ois kiva]

Tietokantaa käytetään tietokannan hallintajärjestelmällä, joka on kokoelma ohjelmia tiedon tallentamiseen, muokkaamiseen, analysoimiseen ja keräämiseen tietokannasta. Hallintajärjestelmää käytetään kyselykielellä, joista esimerkiksi SQL \cite{5391051} on suunniteltu relaatiotietokantojen hallintajärjestelmille. Hallintajärjestelmän vastuulla on kyselyn muuttaminen tietokannan ymmärtämään muotoon säilyttäen kyselyn alkuperäinen tarkoitus. Kyselyn optimointi on toteutettu automaattisena toimenpiteenä hallintojärjestelmän sisältämässä kyselyn optimoijassa, ja kaikista hallintajärjestelmän komponenteista optimoijalla on suurin merkitys tietokannan suorituskykyyn \cite{mor2012}. Kyselyn optimoijan tavoitteena on minimoida itse optimointiin käytetty aika ja maksimoida optimoinnista saatu hyöty \cite{jarke1984}. 

Optimoija toimii arvioimalla osajoukon kaikista menetelmistä kyselyn suorittamiseen ja valitsemalla niistä tehokkaimman menetelmän \cite{selinger1979access}. Menetelmää kyselyn suorittamiseksi sanotaan kyselysuunnitelmaksi, ja se sisältää sarjan tietokannan relaatioihin kohdistuvia algebrallisia operaatioita, jotka tuottavat tulokseksi halutun vastauksen. Tietokantakyselyä vastaavia kyselysuunnitelmia on useita, sillä kysely voidaan usein esittää monena algebrallisesti toisiaan vastaavana esityksenä \cite{jarke1984}. Algebrallista operaatiota kohden voi myös löytyä useita toteutuksia, kuten join-operaatiota toteuttavat merge join, hash join ja nested loop join. Kyselysuunnitelma sisältää operaatioiden lisäksi tiedon ne toteuttavista algoritmeista. Saman kyselyn sisältämät mahdolliset kyselysuunnitelmat voivat olla suorituskyvyltään jopa eri suuruusluokassa \cite{ioannidis1996query, oracle2013refman}. 
%Ongelma

%Pohjan nykyaikaisille kyselyn optimoijille loi System R-hallintajärjestelmän \cite{astrahan1976system} sisältämä optimoija, jonka esittelivät Selinger et al. vuoden 1979 artikkelissaan \cite{selinger1979access}. System R oli ensimmäinen relaatiomalliin \cite{codd1970relational} perustuva hallintajärjestelmä, ja moni nykyinen %hallintajärjestelmä pohjautuu osittain System R:ään.

Tässä tutkielmassa keskitymme kyselyn optimoijan toimintaan ja ongelmiin yleisellä tasolla. Jokainen optimoija on osittain erilainen kokonaisuus komponentteja, jotka kuitenkin pohjautuvat samoihin yleisiin malleihin.

Kyselyn optimointi on NP-täydellinen ongelma \cite{ibaraki1984optimal}, jossa hakualue voi nousta erittäin suureksi. Haasteeksi nousee kyselysuunnitelmien hakeminen ja niiden suorituskyvyn ennustaminen. Kaikkien mahdollisten kyselysuunnitelmien arvioiminen on usein liian hidasta, joten optimoijan tulee valita pienin mahdollinen hakualue joka pitää sisällään halvimmat suunnitelmat \cite{chaudhuri1998}. Suorituskyvyn ennustamisen ja hakualueen rajauksen lisäksi optimoija tarvitsee tehokkaan algoritmin koko hakualueen läpikäymiseen. On epärealistista odottaa kyselyn optimoijan aina löytävän parhaan kyselysuunnitelman, ja onkin tärkeämpää välttää huonoimpia suunnitelmia ja löytää hyvä suunnitelma \cite{ramakrishnan2003database}. 

Luku 2 sisältää esitiedot kyselyn optimoijan toiminnalle, joiden lisäksi luvussa perehdytään optimoijan historiaan ja sen tavoitteisiin. Luku 3 tiivistää tietokantakyselyn prosessoinnin hallintajärjestelmän sisällä ja esittelee optimoijan toiminnan pääpiirteittäin kyselyn prosessoinnissa. Kyselysuunnitelman tuottamiseen syvennytään tarkemmin luvussa 4, jossa käsitellään kyselysuunnitelman rakennetta, niiden tuottamiseen käytettäviä algoritmeja sekä heuristiikkoja epäoptimaalisten kyselysuunnitelmien karsimiseen. Kyselysuunnitelmien kustannusarviointi ja siihen liittyvä tilastotiedon käyttö esitellään luvussa 5. 

\section{Taustaluku}
Tässä luvussa käydään läpi relaatiomallin käsite sekä relaatioalgebran operaatiot, jotka ovat optimoijan keskeisimmät esitiedot. Lisäksi luvussa tutustutaan tarkemmin optimoijan tavoitteisiin ja sen vaikutuksen alaisiin resursseihin, sekä annetaan lyhyt katsaus optimoijan historiaan.
\subsection{Relaatiomalli}
Relaatiotietokanta on relaatiomalliin \cite{codd1970relational} perustuva tietokanta. Relaatiomallin keskeinen piirre on kaiken datan esittäminen n-paikkaisen karteesisen tulon osajoukkona, ja se tarjoaa deklaratiivisen menetelmän datan ja kyselyjen määrittämiseen. Relaatiomalli koostuu attribuuteista, monikoista ja relaatioista, jotka esitetään kuvassa 1. Matemaattisessa määritelmässä attribuutti on pari joka sisältää attribuutin nimen ja tyypin. Jokaiseen attribuuttiin liittyy sen arvojoukko. Monikko on järjestetty joukko attribuuttien arvoja. Relaatio koostuu otsakkeesta ja sisällöstä, jossa otsake on joukko attribuutteja ja sisältö on joukko monikkoja. Relaation otsake on myös jokaisen monikon otsake. Visuaalisessa esityksissä relaatio on taulukko ja monikko taulukon rivi. 

\begin{figure}[!h] %TODO: LISÄÄ VIITE wikipedia relational database
  \caption{Relaatiomalliin perustuva tietokanta.}
  \centering
    \includegraphics[width=\textwidth]{rlt_wiki.png}
\end{figure}

\subsection{Relaatioalgebra}
Relaatioalgebra on relaatiomalliin pohjautuva joukko relaation käsittelyyn tarkoitettuja operaatioita, ja se muodostaa relaatiotietokantojen teoreettisen pohjan. Relaatioalgebran operandit ovat relaatioita, ja sillä on joukko-opin operaatioiden lisäksi omia operaatioita. Tarkastelemme seuraavaksi tärkeimpiä operaatioita.

Liitos (join) on operaatio muotoa $A\bowtie B$, jossa A ja B ovat relaatioita. Liitos tuottaa relaation, joka on kaikkien kombinaatioiden joukko A:n ja B:n yhteisistä attribuuteista. %TODO: Ehkä muutama esimerkki muista join-operaatioista tähän

Valinta (selection) on muotoa $\sigma_{ehto}(A)$, jossa $ehto$ on jokin loogisilla operaatioilla $=$, $\neq$, $\leq$, $\geq$, $\wedge$, $\vee$ vertailtavissa oleva ehto. Valinta tuottaa relaation, joka on joukko kaikista relaation monikoista joille pätee valinnan ehto.	

Projektio (projection) on muotoa $\pi_{a_1,...a_n}(A)$, jossa $a_1,..a_n$ on joukko attribuuttien nimiä. Projektio poimii relaatiosta alijoukon joka sisältää annetut attribuutit.

%Yhdiste (union) $\bowtie$ on operaatio joka muodostaa relaation yhdistämällä kahden relaation monikot. Ol. A ja B ovat monikoita. Nyt yhdiste C = $A \cup B = \{ x | x \in A \cup x \in B \} $
%$\bowtie \sigma \pi$

\subsection{Optimoinnin tavoite}
Tietokantakyselyjen optimoinnilla viitataan tietokantakyselyn suorittamiseen mahdollisimman tehokkaasti. Optimoinnin tavoitteena on joko maksimoida suorituskyky annetuilla resursseilla tai minimodia resurssien käyttö. Jarke ja Koch määrittävät mitattaviksi resursseiksi suorittimen ja muistin käytön sekä kommunikointikustannukset \cite{jarke1984}. Teorey ja Fry \cite{teorey1982design} huomasivat optimoijan vaikuttavan suorittimen palveluaikaan (service time), suorittimen jonotusaikaan, I/O:n palveluaikaan, I/O:n jonotusaikaan ja lukittumisen viiveeseen. Osa tutkimuksista, kuten Kooi:n väitöskirja \cite{kooi1980optimization} kuitenkin sivuuttavat suorittimen käytön kokonaan.

Muistin käyttö jakautuu tallennuskustannukseen sekä ulkomuistiin pääsyn kustannukseen. Tallennuskustannuksella tarkoitetaan ulkomuistin sekä puskurimuistin käyttöä, ja se tulee aiheelliseksi kun muistin käyttö aiheutuu pullonkaulaksi. Kommunikointikustannukset käsittävät tiedon viennin tallennuspaikasta laskentapaikkaan ja edelleen tulosten esityspaikkaan. Ne jakautuvat kommunikaatioväylän käyttökustannukseen ja tiedonsiirrosta aiheutuvaan suorittamisen viiveeseen.

Resurssin merkitys riippuu tietokantatyypistä. Jarke ja Koch erittelivät hajautetuissa tietokannoissa kommunikointikustannukset hallitseviksi kustannuksiksi sekä paikallisissa tietokannoissa kaikki resurssit samanarvoisiksi. Jarken ja Kochin mukaan keskitetyissä tietokannoissa ulkomuistiin pääsyn kustannus ja prosessorin käyttö ovat oleellisia. Tässä tutkielmassa keskitymme erityisesti keskitettyjen tietokantojen optimointiin.

\subsection{Optimoijan historia}
Relaatiomallin myötä optimoinnista tuli osa järjestelmän toiminnallisuutta, sillä se tarjosi deklaratiivisuutensa vuoksi useita tapoja toteuttaa kukin kysely. Ennen relaatiomallin käyttöä optimointi tehtiin käsin.
Selinger et al. esittelivät System R-hallintajärjestelmän OPTIMIZER-komponentin \cite{selinger1979access}, joka on ensimmäisiä relaatiomalliin pohjautuvia kyselyn optimoijia. OPTIMIZER esitteli dynaamisen hakualgoritmin kyselysuunnitelmien luomiseen, ja se on käytössä hieman muunneltuna käytännössä kaikissa kaupallisissa järjestelmissä \cite{ioannidis1996query}. 

%TODO: EXODUS, VOLCANO tähän.

%\section{Kyselyn jäsentäminen} 
%http://docs.oracle.com/cd/B28359_01/server.111/b28318/sqlplsql.htm#i1243

\section{Tietokantakyselyn prosessointi}
Tietokannan hallintajärjestelmän suorittama SQL-kyselyn prosessointi sisältää useita vaiheita. Kuva 2 esittää kyselyn optimointikerroksen ja suorituskerroksen hallintajärjestelmän sisällä. Alempana analysoimme komponenttien toimintaa tarkemmin.

\begin{figure}[!h]
  \caption{Kyselyn jäsentäminen, optimointi ja suoritus \cite{ramakrishnan2003database}.}
  \centering
    \includegraphics[width=\textwidth]{optimoija60.png}
\end{figure}

\subsection{Kyselyn jäsentäminen}
Kyselyn prosessointi alkaa kyselyn jäsentäjän suorittamalla kyselyn syntaksin validoinnilla \cite{selinger1979access}. Syntaksin validoinnissa jäsentäjä tarkastaa kyselyn lauseopin oikeellisuuden. Osa hallintajärjestelmistä, kuten Oracle 11g, validoi myös samalla semantiikan oikeellisuuden \cite{oracle2009doc}. 
Semantiikan validoinnissa tarkastetaan objektien aitous, kyselyn yksiselitteisyys, oikeus haettavaan tietoon ja muuttujien tyypin sopivuus sarakkeiden tyyppeihin. Useat hallintajärjestelmät myös
tallentavat kyselyt validoinnin jälkeen, jotta samaa kyselyä ei tarvitse jäsentää ja optimoida uudelleen. Yksi esimerkki kyselyjä tallentavasta hallintajärjestelmästä on Oracle Database, jossa tallennuspaikkaa kutsutaan nimellä Shared Pool \cite{oracle2005doc}. 

Seuraavaksi jäsentäjä jakaa kyselyn lohkoihin (block) siten, että yhdessä lohkossa on täsmälleen yksi SELECT-lause, yksi FROM-lause ja korkeintaan yksi WHERE-, GROUP BY- ja HAVING-lause \cite{ramakrishnan2003database}. 
Kyselyn mahdollisesti sisältämät alikyselyt muodostavat kukin oman lohkonsa. Alikyselyitä tarkastellaan luvussa 4.3.

Jokainen lohko jäsennetään puuksi, joka on kyselyn algebrallinen esitysmuoto \cite{mahajan2012}. 
Puun solmu sisältää yhden operaation kyselyn suorittamiseksi, ja sillä on nolla tai useampi alisolmua joiden ulostuloa (output) käytetään sen syötteenä.
Esimerkiksi join-operaatiossa solmulla on kaksi alisolmua, joille toteutetaan join-operaatio ja sort-operaatiolla on yksi alisolmu joka järjestetään.
Lehtisolmut ovat solmuja jotka suorittavat hakuja (scan) levyltä ja palauttavat saadut tulokset. 
Puu suoritetaan lehtisolmuista juureen.

Tämän jälkeen monimutkaiset kyselyt uudelleenkirjoitetaan (rewrite) soveltamalla niihin muutossääntöjä \cite{ioannidis1996query}. Pirahesh et al. tutkivat uudelleenkirjotusta Starburst-hallintajärjestelmän osalta artikkelissa \cite{pirahesh1992extensible}. He määrittivät uudelleenkirjoituksen tavoitteiksi tehdä kyselyistä mahdollisimman deklaratiivisia ja suorittaa luonnollisia heuristiikkoja. Yksi heuristiikka on operaatioiden siirtäminen suoritettavaksi mahdollisimman aikaisessa vaiheessa, kuten tietokantataulun lukemisen aikana.
%Viitteiden käytöstä: aiemmassa artikkelissa määritellään uudelleenkirjoituksen paikka, toisessa sen toiminta.

% valitsemalla hakumetodit (access method), liittämisjärjestyksen (join orders) ja liittämistavat (join methods) tietokannan käyttämien heuristiikkojen pohjalta.  Monimutkaisille kyselyille sovelletaan myös muunnossääntöjä \cite{mahajan2012}.
%Uudelleenkirjoituksen tarkoitus on helpottaa optimoijan työtä parhaan kyselysuunnitelman valinnassa.
%todo: http://docs.oracle.com/cd/A97630_01/server.920/a96520/qr.htm
%http://www.budaconsulting.com/blog/bid/79324/Query-Rewrite-What-is-MySQL-Doing-To-My-Queries

\subsection{Kyselyn optimointi}
Kun kysely on jäsennetty ja mahdollisesti uudelleenkirjoitettu, lähetetään se kyselyn optimoijalle. Kyselyn optimoija hakee tietokannan systeemitaulustoon tallennettua tilastotietoa kyselyyn liittyvistä relaatioista ja relaatioihin liittyvistä saantipoluista (access path). Tilastotietoa käytetään kyselyn suorituskyvyn arviointiin. Saantipolku on menetelmä jolla taulurivit haetaan taulusta, ja se muodostuu joko tiedoston lukemisesta tai indiksien käytöstä. Selinger et. al. tutkivat kattavasti saantipolkujen kustannusarviointia artikkelissaan \cite{selinger1979access}. 

Mikäli kyselyn semantiikkaa ei ole vielä tarkastettu, tarkastaa optimoija kyselyn semantiikan oikeellisuuden ja kyselyn tyyppien sopivuuden sarakkeisiin ja operaatioihin systeemitaulun tiedon pohjalta.  Optimoija määrittää lohkojen suoritusjärjestyksen ja käy läpi saantipolut jokaisen lohkon FROM-lauseen relaatioiden lukemiseen. Mikäli lohkossa on useampi relaatio, arvioi optimoija join-operaation järjestyksen ja suoritustapojen suorituskyvyt ja valitsee tehokkaimman algoritmin operaatioiden suorittamiseen. Optimoija valitsee jokaiselle lohkolle vähiten resursseja käyttävän saantipolun ja rakentaa niistä kyselysuunnitelman \cite{selinger1979access}.

\subsection{Kyselyn suorittaminen}
Seuraavassa vaiheessa kysely suoritetaan käyttämällä optimoijan tuottamaa kyselysuunnitelmaa. Suorittamisessa kyselysuunnitelma muutetaan suoritettavaksi konekieleksi ja kyselyn lähteen mukaan joko suoritetaan tai tallennetaan muistiin myöhempää suorittamista varten. 

\section{Kyselysuunnitelmien tuottaminen} 
Kyselyn optimoijan tulee tuottaa mahdollisimman suorituskykyisen kyselysuunnitelman sisältämä joukko käyttämättä tuottamiseen liikaa resursseja. Tässä luvussa perehdymme ensiks kyselysuunnitelman rakenteeseen. Tämän jälkeen tutkimme algoritmeja kyselysuunnitelmien joukon luomiseen, sekä heuristiikkoja epäoptimaalisten kyselysuunnitelmien karsimiseen. Luvun lopuksi tutkimme alikyselyjen suorittamista.

\subsection{Kyselysuunnitelma}
Kyselysuunnitelma koostuu laajennetusta relaatioalgebrapuusta, jossa jokainen solmu kuvaa algebrallista operaatiota. Solmuun on liitetty tieto käytettävästä hakumetodista tiedon hakemiseen taulusta ja suoritusmetodista operaation suoritukseen. Kyselysuunnitelma sisältää kaikki tiedot jotka hallintajärjestelmä tarvitsee halutun tiedon hakemiseen tietokannasta. Tutkitaan seuraavaa SQL-kyselyä:
\newline

\begin{frame}

SELECT K.nimi

FROM Kirjat K, Teokset T

WHERE K.tid = T.tid AND K.kid = 5 AND T.arvosana $\textgreater$  3
\end{frame}
\\\newline
Kysely voidaan tulkita relaatioalgebrassa seuraavasti:
\newline

\begin{frame}

$\pi$$_{nimi}$(\sigma_{kid=5 \wedge arvosana \textgreater 3}(Kirjat$\Join$$ _{tid=tid}$Teokset))
\end{frame}
\\\newline
Kysely voidaan suorittaa esimerkiksi käyttäen join-operaatiossa nested loop join-algoritmia, jonka jälkeen jokaiselle riville suoritetaan 
valinta ja projektio. Kyselyä vastaava esimerkkikyselysuunnitelma esitetään kuvassa 3.

\begin{figure}[!h] 
  \caption{Kyselysuunnitelma erimerkkikyselylle.}
  \centering
    \includegraphics[width=\textwidth]{queryevalplan60.png}
\end{figure}
\\\newline
Join-operaatiossa voidaan käyttää hyväksi putkitusta (pipelining) \cite{dalvi2001pipelining}, jossa operandi putkitetaan suorituksen aikana toiseen operaatioon ilman väliaikaista taulua tuloksen tallentamiseen, lennossa. Ilman putkitusta väliaikaiset tulokset tulee tallentaa väliaikaiseen muuttujaan. Putkitusta käytetään usein peräkkäisten join-operaatioiden toteuttamiseen, jolloin jokainen operaation palauttama operandi voidaan syöttää seuraavan operaation parametriksi. Putkitusta voidaan käyttää operaation suorittavan algoritmin salliessa sen.

Usein tehokkaampi tapa kyselyn suorittamiseen on suorittaa valinnat mahdollisimman aikaisessa vaiheessa \cite{ramakrishnan2003database}. Esimerkkikyselyssä tauluille suoritetaan kullekin valinta erikseen, joten suorittamalla ne ennen join-operaatiota voidaan vähentää yhdistettävien alkioiden määrää. Tehokkaampi kyselysuunnitelma aikaisilla valinnoilla, tallentaen valinnat väliaikaismuuttujiin T1 ja T2, esitetään kuvassa 4. Edelleen tehokkaampi tapa olisi välikaikaiseen muuttujaan tallentamisen sijaan putkittaa valinta-operaatiosta alkiot suoraan join-operaatioon.

 \begin{figure}[!h] 
  \caption{Suorituskykyisempi kyselysuunnitelma erimerkkikyselylle.}
  \centering
    \includegraphics[width=\textwidth]{queryevalplan60better.png}
\end{figure}
\\\newline
%
\subsection{Hakualgoritmit}
%Kyselyn optimoijan tulee rakentaa mahdollisten kyselysunnitelmien joukko. 
Kyselyn optimoija tarvitsee tehokkaan algoritmin mahdollisten kyselysuunnitelmien luomiseen. Jarke ja Koch määrittelevät artikkelissaan \cite{jarke1984} kaksi tapaa kyselysuunnitelman valintaan. Ensimmäisessä tavassa arvioidaan jokaisen erillisen kyselysuunnitelman kustannus, jolloin hyvä suunnitelma löydetään mutta optimointiin kulunut aika on suuri. Toisessa tavassa kustannus lasketaan inkrementaalisesti niiden rakentamisen aikana, ja suorituskyvyltään huonoksi havaitut kyselysuunnitelmat karsitaan pois. Selinger et al. esittelemä dynaaminen algoritmi \cite{selinger1979access} on toisen tavan laajennus, jossa algoritmi arvioi operaation ja sen mahdolliset vaikutukset seuraaviin operaatioihin kerrallaan. 

Kyselysuunnitelmat sisältävä hakualue voi kasvaa erittäin suureksi kyselyn ollessa laaja. Useat optimoijat käyttävät heuristiikkoja, kuten valinnan suorittamista mahdollisimman aikaisin tai vain tietynlaista join-operaatioiden järjestyksen hyväksymistä, pienentääkseen kyselysuunnitelmien määrää. Optimoija voi näin karsia tarkasteltavien kyselysuunitelmien määrää. Tavoitteena on pitää hakualue mahdollisimman pienenä, sisältäen kuitenkin optimaalisen suunnitelman \cite{jarke1984}. Luvussa 4.2.1 tutustutaan tarkemmin dynaamisiin algoritmeihin sekä luvussa 4.2.2 vaihtoehtoisiin algoritmeihin hakualueen läpikäymiseen, kuten sääntöihin perustuvaan Starburst-hallintajärjestelmälle kehitettyyn algoritmiin \cite{lohman1988grammar}. Lopuksi luvussa 4.2.3 käsitellään yleisiä optimoijan käyttämiä heuristiikkoja.

%Chaudhurilla paljon tietoa http://www.cs.washington.edu/education/courses/cse544/99sp/chaudhuri.pdf
\subsubsection{Dynaamiset algoritmit}
Selinger et al. System R:lle esittelemä algoritmi on dynaaminen karsiva ja tyhjentävä (exhaustive) hakualgoritmi. Dynaamista algoritmia pidetään standardina algoritmina optimoijalle, ja usean hallintajärjestelmän hakualgoritmi pohjautuu dynaamiseen algoritmiin sisältäen kuitenkin hieman variaatioita. Algoritmi rakentaa kaikki mahdolliset join-puut käyttämällä heuristiikkoja ja karsii alioptimaalisiksi tiedetyt puut. Selinger et al. esittelemän algoritmin käyttämät heuristiikat ovat predikaattien ja valintojen suorittaminen mahdollisimman aikaisin ja niiden putkitus, karteesisten tulojen välttäminen sekä pelkästään vasemmalta syvien puiden käyttö join-operaation suorituksessa. Heuristiikkoja tutkitaan tarkemmin luvussa 4.2.3. Algoritmi huomioi join-operaation suorittamiseen vain nested loop join- ja merging scans-algoritmit, joiden Selinger et al. huomasivat lähes aina tuottavan optimaalisen tai lähes optimaalisen suorituskyvyn muille paitsi erittäin pienille relaatioille.
\subsubsection{Muut algoritmit}
Dynaamisten algoritmien kilpailijoita ovat satunnaistetut algoritmit, kuten Iterative Improvement \cite{nahar1986simulated}, jossa algoritmi pyrkii dynaamisten algoritmien kyselysuunnitelmien tuottamisen sijaan rakentamaan yhden mahdollisimman hyvän suunnitelman. Algoritmi käy satunnaisesti läpi verkon solmuja, jossa jokainen solmu kuvaa yhtä kyselysuunnitelmaa johon on liitetty sen kustannus. Iterative Improvement valitsee vain siirtoja alamäkeen, jossa kohdesolmun kustannus on pienempi kuin lähtösolmun, ja lopuksi palauttaa reitin varrelta löydetyn pienimmän kustannuksen sisältävän solmun.

Satunnaisten algoritmien lisäksi geneettiset algoritmit, kuten Bennet et al. esittelemä algoritmi \cite{bennett1991genetic}, ovat tutkimuksen kohteena. Geneettinen algoritmi koostuu kromosomeista, jotka ovat ratkaisuita ongelmaan ja vertailtavissa keskenään niiden kunnon (fitness) mukaan. Geneettinen algoritmi simuloi biologista ilmiötä, jossa kromosomeja verrataan keskenään niiden kunnon mukaan ja niistä luodaan jälkeläinen joka perii vanhemmilta ominaisuuksia. Heikommat kromosomit karsiutuvat pois ja suorituskykyisemmät jatkavat seuraavaan sukupolveen. Bennet et al. algoritmissa kromosomit ovat binääripuita, joiden solmuissa on tieto kunkin operaation kustannuksesta. Suorituskykyisimmät jälkeläiset selviytyvät jatkoon, ja lopputuloksena saadaan optimaalinen ratkaisu. 
\subsubsection{Algoritmien heuristiikat}
Optimoija voi suorittaa usean peräkkäisen join-operaation liittämisen monella eri tavalla. Ono ja Lohman tutkivat join-operaation suorittamisjärjestysten vaikutusta tarkemmin artikkelissaan \cite{ono1990}, ja huomasivat join-operaation järjestyksen olevan hallitseva kustannus kyselyn optimoinnissa. 

Tutkitaan kyselyä $Kirjat \Join Teokset \Join Kirjailijat \Join Maat$. Vasemmalta syväksi (left-deep) puuksi kutsutaan tapaa liittää kyselyt seuraavasti: $(((Kirjat \Join Teokset) \Join Kirjailijat) \Join Maat)$, jossa oikea lapsi on aina kantataulu. Lehtevä puu taas on puu, jossa myös oikea lapsi voi olla join-operaation tulos: $(((Kirjat \Join Teokset) \Join (Kirjailijat \Join Maat)$ Kuva 5 havainnollistaa vasemmalta syvät ja lehtevät puut. Optimoijat käyttävät usein pelkästään vasemmalta syviä puita, sillä eri tapoja liittää join-operaatioita on join-operaatioiden määrän kasvaessa erittäin paljon. Käyttämällä vain vasemmalta syviä puita voidaan pienentää hakualuetta \cite{ioannidis1991left}, ja vasemmalta syvät puut mahdollistavat putkituksen. Oikea lapsisolmu eli join-operaation sisempi taulu täytyy aina materialisoida, sillä se täytyy käydä läpi jokaiselle ulomman taulun eli vasemman lapsisolmun monikolle \cite{ramakrishnan2003database}. 

\begin{figure}[!h]
  \caption{Vasemmalta syvät ja lehtevät puut.}
  \centering
    \includegraphics[width=\textwidth]{leftdeepbushytrees.png}
\end{figure}

Ioannidis ja Cha Kang tutkivat artikkelissaan \cite{ioannidis1991left} left-deep puiden ja lehtevien (bushy) puiden suorituskykyeroja, ja huomasivat sekä lehtevien puiden että vasemmalta syvien puiden samanaikaisen käytön olevan helpompaa ja sen tuottavan parempia tuloksia kuin vain vasemmalta syvien puiden käytön. Lehtevä puu mahdollistaa suuremman joukon mahdollisia kyselysuunnitelmia, joten se usein sisältää vasemmalta syviin puihin verrattuna huonompia suunnitelmia mutta usein myös optimaalisen suunnitelman.

Yleinen optimoijien käyttämä heuristiikka on myös predikaattien suorittaminen samaan aikaan relaatioiden ensimmäisen haun yhteydessä. Predikaateista projektio pyritään suorittamaan suoraan muiden operaatioiden tulosjoukolle. Levy et al. esittelivät artikkelissaan \cite{levy1994query} tavan siirtää predikaatteja lohkojen välillä, jolloin predikaatit voidaan suorittaa yhä aiemmin ja siten vähentää väliaikaisen tulosjoukon kokoa. He myös esittelivät aritmeettisesti vertailtavissa olevien predikaattien lisäksi tavan siirtää negatiivisia predikaatteja, kuten NOT EXISTS ja EXCEPT. Predikaattien suorittaminen mahdollisimman aikaisin ei kuitenkaan aina tuota suorituskykyisintä tulosta. \cite{ramakrishnan2003database} Mikäli taulut on indeksoitu, voi valinta kadottaa tärkeät indeksit jolloin join-operaation suorittaminen hidastuu.

Tärkeä heuristiikka on lisäksi karteesisten tulojen välttäminen join-operaation suorituksessa mikäli kysely ei erityisesti vaadi niitä. Heuristiikkaa toteuttava algoritmi tuottaa join-operaation suoritukseen vain vaihtoehdot jotka eivät sisällä karteesista tuloa. Chaudhuri havaitsi artikkelissaan \cite{chaudhuri1998} karteesisten tulojen välttämisen toisinaan johtavan huonompaan suorituskykyyn. 

Laajennetuissa optimoijissa heuristiikkoja voidaan vaihtaa kyselykohtaisesti \cite{chaudhuri1998}, kuten toisinaan sallimalla lehtevien puiden läpikäyminen tai karteesisten tulojen käyttäminen. On kuitenkin erittäin vaikeaa määritellä heuristiikkojen vaikutukset etukäteen. Yksi ratkaisu ongelmaan on geneettisten algoritmien \cite{bennett1991genetic} käyttö parhaiden heuristiikkojen määrittämiseen.
\subsection{Alikyselyt}
Kyselyn predikaatin operandin ollessa toinen kysely puhutaan alikyselystä. Won Kim esitteli strategian \cite{kim1982optimizing}, jossa alikysely suoritetaan ennen ulompaa kyselyä ja saatu tulos liitetään ulomman kyselyn predikaatiksi. Kim jakoi alikyselyt viiteen luokkaan niiden sisältämien predikaattien mukaan. Tutkimme seuraavaksi näistä viidestä luokasta kahta luokkaa, joissa alikysely ei sisällä join-operaatiota joka viittaa ulompaan kyselyyn. Tällaisessa tapauksessa alikysely voidaan suorittaa omana lohkonaan. 
\newline

\begin{frame}

SELECT nimi

FROM Kirjat

WHERE hinta = 

\hspace*{5mm}(SELECT AVG(hinta)
		
\hspace*{5mm}FROM Kirjat)
\end{frame}
\\\newline
Esimerkkikyselyssä alikyselyn palauttama arvo lisätään ulompaan kyselyyn predikaatiksi niinkuin se olisi ollut osa ulompaa kyselyä. Esimerkkitapauksessa AVG(hinta) palauttaessa arvon 10 predikaatiksi saadaan "hinta = 10". Alikysely voi myös palauttaa joukon monikkoja, kuten seuraavassa tapauksessa:
\newline

\begin{frame}

SELECT nimi

FROM Kirjat

WHERE tid IS IN 

\hspace*{5mm}(SELECT tid
		
\hspace*{5mm}FROM Teokset

\hspace*{5mm}WHERE arvosana $>$ 3)
\end{frame}
\\\newline
Tällöin ulompaan kyselyyn liitetään predikaatti "tid IS IN X", jossa X on alikyselyn palauttama joukko monikoita. Mikäli alikysely sisältää join-operaation viitaten ulompaan kyselyyn, joudutaan join-operaatio suorittamaan ennen alikyselyn suorittamista. Alikyselyn paluuarvo voidaan kuitenkin edelleen liittää ulomman kyselyn predikaatiksi.

%Ganski ja Wong (Optimization of nested SQL queries revisited) löysivät algoritmeista bugeja ja kehittivät hieman, ei ehkä mainitsemisen arvoista.

\section{Kyselysuunnitelmien kustannusarviointi}
Kyselysuunnitelmien kustannusarvioinnissa optimoijan tulee arvioida kyselysuunnitelmien operaatioiden suorittamiseen kuluva aika sekä niiden tulosjoukon koko. Kyselysuunnitelman kustannus on sen sisältämien operaatioiden kustannusten summa, ja operaatioiden kustannukseen vaikuttaa olennaisesti sen operandien koko. Yksittäisten operaatioiden kustannus arvioidaan käyttämällä systeemitaulustoon tallennettua tilastotietoa operandeihin liittyvistä tiedoista, kuten järjestyksestä ja koosta. %TODO: avaa systeemitaulusto!!!

Optimoija käyttää kustannusarvointiin joko heuristisia arvioita tai kustannusmallia (cost model) \cite{jarke1984}, joista tutkimme tarkemmin kustannusmallia. Kustannusmallissa optimoija arvioi jokaisen operaation kustannuksen ja tulosjoukon koon, sillä operaation tulosjoukko on usein seuraavan operaation parametri. Kustannusmallin tuottaman kustannusarvion perusteella voidaan valita paras kyselysuunnitelma. Luvussa 5.1 tutustutaan tarkemmin systeemitaulustoon tallennettavaan tilastotietoon, ja luvussa 5.2 käsitellään systeemitauluston tilastotiedon pohjalta tehtävää kyselysuunnitelman kustannusarviointia.

%Kustannusarviointi koostuu kahdesta vaiheesta: ensiksi arvioidaan jäsennetyn puun jokaisen alkion operaation suorittamiseen kuluva aika.
%Tämän jälkeen arvioidaan jokaisen alkion tulosjoukon koko, sekä tarkastetaan onko tulosjoukko järjestetty. Solmun tulosjoukko on ylisolmun syöte, joten sen koko ja järjestys vaikuttavat suoraan ylisolmun arviointiin.
%(1) Taulujen luku
%(2) Väliaikaisten taulujen luoti
%(3) sort

\subsection{Systeemitauluston tilastotieto}
Systeemitaulusto sisältää tietokannan tilastollisen profiilin. Tilastotiedon avulla pyritään arvioimaan predikaattien ja operaatioiden kustannuksia käyttämällä tilastotietoa niiden operandeista. Mannino et al. tutkivat kattavasti tilastotiedon käyttöä kyselyn optimoinnissa artikkelissaan \cite{mannino1988statistical}. Heidän mukaan tarkka tilastotiedon tallentaminen on tärkeää kyselyn optimoinnille, mutta liian täsmällinen tallentaminen aiheutuu rasitteeksi.

Artikkelissa tilastollinen profiili jaettiin neljään kategoriaan: (1) keskitietoihin kuten moodi, mediaani ja keskiarvo,  (2) hajontaan kuten varianssi sekä pienin ja suurin arvo, (3) kokoon kuten mahtavuus ja eri arvojen lukumäärä sekä (4) frekvenssin jakaantumiseen kuten normaalius ja tasaisuus. Systeemitaulusto sisältää myös jokaisesta taulusta tiedot sen nimestä ja tiedoston nimestä,  attribuuttien tyypeistä ja nimistä, indekseistä ja niiden nimistä ja hakuavaimista sekä yleisistä tiedoista kuten sivukoosta ja puskurimuistin koosta. Hallintajärjestelmät tyypillisesti tallentavat tilastotiedon systeemitaulustoon histogrammeihin \cite{chaudhuri1998}, joissa tieto jaetaan lohkoihin. Optimoija voi tällöin ladata muistiin vain kulloinkin relevantit lohkot. %Lisää histogrammeista: ftp://ftp10.us.freebsd.org/users/azhang/disc/SIGMOD/pdf-files/223/230-global.pdf

Bruno et al. tarkastelivat tutkimuksessaan \cite{bruno2002exploiting} tilastotiedon laajentamista väliaikaisiin tuloksiin, ja he huomasivat ratkaisun tuottavan parempia kyselysuunnitelmia kuin pelkän tietokannan taulun tilastotiedon käytön.

\subsection{Tulosjoukon koon arviointi}
Predikaatin kustannus riippuu sen syötteen koosta ja järjestyksestä. Tutkitaan seuraavaa tapausta:
\newline

\begin{frame}

SELECT attribuuttit

FROM relaatiot

WHERE ehto 1 $\wedge$ ehto 2 $\wedge$ ... $\wedge$ ehto n
\end{frame}
\\\newline
Kyselyn palauttamien monikkojen maksimimäärä on relaatioiden karteesinen tulo. Jokainen WHERE-ehto harventaa monikkojen määrää. WHERE-ehdon vaikutusta tulosjoukon kokoon voidaan mallintaa lisäämällä jokaiseen ehtoon vähennyskerroin, joka on oletettu suhde lähtöjoukosta tulosjoukkoon vain kyseisen ehdon osalta. 
Tulosjoukon koko voidaan siten arvioida kertomalla maksimijoukko vähennyskertoimien tulolla \cite{ramakrishnan2003database}. 

WHERE-lauseen ehtojen kertoimia voidaan laskea hyödyntämällä systeemitaulustoon tallennettua tilastotietoa. Selinger et al. määrittävät artikkelissaan \cite{selinger1979access} laskukaavoja vähennyskertoimien laskemiseen. He myös määrittivät oletuskertoimet relaatioille, joille arvioinnin kannalta olennaista tilastotietoa ei ole saatavilla. Oletetaan seuraavat tiedot:
\\\newline
$NKeys(I)$ = eri avainten lukumäärä indeksissä I
\\
$F$ = vähennyskerroin
\\\newline
$sarake = arvo$ 
\\
Tämän tyyppiselle ehdolle vähennyskerroin voidaan arvioida kaavalla $F = \frac{1}{NKeys(I)}$, jos sarakkeessa on indeksi kyseiselle relaatiolle. \cite{selinger1979access} Ilman indeksiä kyselyn optimoija käyttää kiinteää arvoa vähennyskertoimen arvioimiseen, joka esimerkiksi System R-relaatiotietokantaohjelmassa on 1/10.
\\\newline
$sarake1 = sarake2$ 
\\
Tässä tapauksessa voidaan vähennyskerroin arvioida käyttäen kaavaa $F = \frac{1}{MAX (NKeys(I1), NKeys(I2))}$ jos kummassakin sarakkeessa on indeksi. Lisäksi oletetaan, että jokaisesta pienemmän indeksin arvoa vastaa arvo toisesta indeksistä. Mikäli vain toisessa sarakkeessa on indeksi, 
voidaan kustannus laskea aiemmalla kaavalla käyttäen indeksin omaavaa saraketta. Mikäli kummassakaan sarakkeessa ei ole indeksiä, arvioidaan arvoksi 1/10.

Join-predikaatin suorittamisessa merkittävää kustannusarvioinnin kannalta on sen suorittava algoritmi sekä join-predikaattien järjestys. Nested loop join- sekä merging scans-algoritmit ovat yleisesti käytettyjä, ja jälkimmäinen vaatii liitettävien relaatioiden olevan järjestyksessä liitettävien attribuuttien mukaan. Optimoijan tulee tällöin ottaa arvioinnissa huomioon relaation järjestämiseen kuluvat resurssit. Mahdolliset indeksit vaikuttavat myös olennaisesti algoritmien kustannuksiin. 
\section{Yhteenveto}
Kyselyn optimoijan tehtävä on tuottaa mahdollisten kyselysuunnitelmien joukko, arvioida niiden kustannus tilastotiedon pohjalta ja valita niistä paras. Kustannus koostuu kyselysuunnitelman suorittamiseen käytetyistä resursseista. 

Kyselysuunnitelmien tuottamisessa kaikkien suunnitelmien läpikäyminen on kuitenkin usein liian hidasta, joten kyselysuunnitelmien joukkoa pyritään karsimaan heuristiikkojen avulla. Heuristiikkojen käyttäminen ei ole triviaalia, sillä toisinaan paras kyselysuunnitelma karsitaan heuristiikan takia.

Kyselysuunnitelmien kustannusarviossa ajankohtainen ongelma on tilastotiedon optimaalinen tallentaminen. Liian tarkka tilastotiedon tallentaminen rasittaa tietokannan käyttöä, mutta auttaa kyselysuunnitelmien optimoinnissa.
\newpage

%\bibliographystyle{unsrt}
\bibliographystyle{babalpha}
\bibliography{references-fi}


\end{document}

% TODO:
% join-operaatio -> liitos-operaatio?


